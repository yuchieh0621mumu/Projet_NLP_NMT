Bonjour, je m’appelle Elena et je vais vous présenter notre travail, détecter les emprunts non assimilés en espagnol : un corpus annoté et des approches de modélisation. Nous allons donc couvrir ce qu’est l’emprunt lexical, la tâche que nous avons proposée, les données que nous avons publiées et certains modèles que nous avons explorés. Mais pour commencer, qu’est-ce que l’emprunt lexical et pourquoi est-ce important en tant que tâche de TAL traitement automatique du langage naturel ? Eh bien, l’emprunt lexical est fondamentalement l’incorporation de mots d’une langue dans une autre langue. Par exemple, en espagnol, nous utilisons des mots qui viennent de l’anglais. Et ici, vous avez quelques exemples : des mots tels que podcast, app et crowdfunding en ligne ; tous ces mots sont des mots anglais que nous utilisons parfois en espagnol. L’emprunt lexical est un type d’emprunt linguistique qui consiste essentiellement à reproduire dans une langue des modèles d’autres langues. Et l’emprunt et l’alternance codique ont parfois été comparés et décrits comme un continuum, l’alternance codique étant la chose que font les bilingues lorsqu’ils mélangent deux langues en même temps. Il y a cependant quelques différences entre l’emprunt lexical et l’alternance codique. Nous allons nous concentrer sur l’emprunt lexical. L’alternance codique est quelque chose qui est fait par les bilingues et par définition, les alternances codiques ne sont pas intégrées dans l’une des langues utilisées, alors que l’emprunt lexical est quelque chose qui est également fait par les monolingues. Les emprunts seront conformes à la grammaire de la langue du destinataire. Et les emprunts peuvent éventuellement être intégrés dans la langue du destinataire. Alors pourquoi emprunter un phénomène intéressant ? Eh bien, du point de vue de la linguistique, l’emprunt est une manifestation de la façon dont les langues changent et comment elles interagissent. Et aussi, les emprunts lexicaux sont une source de nouveaux mots. Ici, vous avez quelques exemples d’emprunts lexicaux qui ont été incorporés dans la langue espagnole en tant que nouveaux mots. En termes de TAL traitement automatique du langage naturel, les emprunts sont une source courante de mots hors-vocabulaire. Et en effet, détecter automatiquement les emprunts lexicaux s’est avéré utile pour les tâches downstream de TAL traitement automatique du langage naturel telles que l’analyse syntaxique, la synthèse texte-parole ou la traduction automatique. Il y a eu un intérêt croissant pour l’influence de l’anglais sur d’autres langues, en particulier les emprunts lexicaux anglais, des emprunts qui ont parfois été appelés anglicismes. Et ici, vous avez quelques exemples de travail sur la détection automatique des emprunts dans certaines de ces langues. Donc, la tâche que nous proposons est de détecter les emprunts lexicaux non assimilés dans le fil d’actualité espagnol. Ce qui signifie que cela nous intéresse d'extraire les mots empruntés à d’autres langues qui sont utilisés dans les journaux espagnols, mais qui n’ont pas été intégrés ou assimilés dans la langue du destinataire. Donc pas encore intégrés à l’espagnol. Vous avez ici un exemple. Ceci est une phrase en espagnol : Las prendas bestsellers se estampan con motivos florales, animal print o retales tipo patchwork. Hum, et comme vous pouvez le voir, il y a trois étendages de textes qui sont en réalité des mots anglais comme bestseller, animal print et patchwork. Il s’agit du type d’étendages qu'il nous intéresse d'extraire et de détecter. Il y a eu un mot antérieur sur la détection de l’anglicisme qui consiste en un modèle CRF pour la détection de l’anglicisme sur le fil d’actualité espagnol. Ce modèle a obtenu un score F1 de quatre-vingt-six. Mais il y avait des limites à la fois dans les données et dans l’approche de modélisation. Ainsi, les données se concentraient exclusivement sur une source d'actualités, ne comprenaient que des titres. Et il y avait aussi un chevauchement dans les emprunts qui apparaissent dans l’ensemble de formation et l’ensemble de test. Cela a empêché d’évaluer si l’approche de modélisation pouvait effectivement se généraliser aux emprunts précédemment invisibles. Nous visons donc à nous attaquer à certaines de ces limites dans la tâche. Alors, pour commencer, nous avons créé de nouvelles données. Avec de nouvelles données qui ont été annotées avec des emprunts lexicaux, le but était de créer un ensemble de test aussi difficile que possible. Il y aurait donc un chevauchement minimal entre les mots et les sujets entre l’ensemble de formation et l’ensemble de test. Et par conséquent, eh bien, l’ensemble de test provient de sources et de dates que nous ne voyons pas dans l’ensemble de formation. Ici, vous pouvez voir qu’il n’y a pas de chevauchement dans le temps. L’ensemble de test est aussi très dense en termes d’emprunt. Juste pour vous donner quelques chiffres, si l’ensemble de formation contient six emprunts pour mille gages, l’ensemble de test contenait vingt emprunts pour mille gages. L’ensemble de test contenait autant de mots hors-vocabulaire que possible. En effet, quatre-vingt-douze pour cent des emprunts dans l’ensemble de test sont des OOV. Ils n’ont donc pas été vus pendant la formation. Et le corpus consistait essentiellement en une collection de textes provenant de différentes sources de journaux espagnols. Et il a été annoté à la main en utilisant deux étiquettes. Une pour les emprunts lexicaux anglais, constituant la majorité des emprunts lexicaux en espagnol, puis l’autre étiquette pour les emprunts d’autres langues. Nous utilisons les formats CoNLL et avons utilisé l’encodage BIO pour pouvoir encoder des emprunts de gages simples tels que app ou des emprunts de gages multiples tels que l'apprentissage automatique. Ce sont les chiffres du corpus. Comme vous pouvez le voir, il s’élève à environ trois cent soixante-dix mille gages. Et ici, vous avez le nombre d’étendages qui ont été étiquetés comme anglais et les étendages qui ont été étiquetés comme autres emprunts, et combien d’entre eux étaient uniques. Et ici, vous avez quelques exemples de l’ensemble des données. Comme vous pouvez le voir ici, par exemple, nous avons dans le premier exemple le batch cooking emprunteur qui est un emprunt de mots multiples. Et nous l’avons annoté en utilisant l’encodage BIO. Donc le BIO a été utilisé pour des mots en espagnol, et non pour des mots qui n’ont pas été empruntés. Et ici, dans ce deuxième exemple, vous avez benching et crash qui sont également étiquetés comme des emprunts de l’anglais. Donc, une fois que nous avons eu les données, nous avons exploré plusieurs modèles pour la tâche d’extraction et de détection de ces emprunts lexicaux. Le premier que nous avons essayé était le modèle de champ aléatoire conditionnel. Ah, c’était le modèle qui avait été utilisé sur le travail antérieur. Et nous avons utilisé les mêmes fonctions faites main à partir de celles de ce travail. Comme vous pouvez le voir, voici les fonctions. Ce sont des fonctions binaires telles que le mot ou le gage en majuscules ? Est-ce une casse de titre ? Est-ce un guillemet ? Des choses comme ça, qui sont le type de fonctions que l’on attendrait d’une tâche de named entity recognition. Voici les résultats que nous avons obtenus. Nous obtenons cinquante-cinq points en F1 en utilisant le modèle CRF avec des fonctions faites main. Ce qui est une énorme différence comparée au score F1 de quatre-vingt-six rapporté, qui était le résultat obtenu avec le même modèle CRF, les mêmes fonctions mais sur des données différentes également pour la détection de l’emprunt lexical espagnol. Donc, cela prouve que les données que nous avons créées sont plus difficiles et que nous devions explorer des modèles plus sophistiqués pour ces tâches. Nous avons donc testé deux modèles basés sur la conversion. Nous avons utilisé BETO qui est un modèle de Représentations d'encodeurs bidirectionnels à partir de transformateurs monolingue formé pour l’espagnol, mais aussi des Représentations d'encodeurs bidirectionnels à partir de transformateurs multilingues. Nous utilisons les deux modèles à travers la bibliothèque de conversion d’HuggingFace. Voici les résultats que nous avons obtenus. Comme vous pouvez le voir, les Représentations d'encodeurs bidirectionnels à partir de transformateurs multilingues fonctionnent mieux que les BETO à la fois sur l’ensemble de développement et sur l’ensemble de test, et à travers tous les indicateurs. Juste pour que nous ayons une idée à comparer, le modèle CRF a obtenu un quatre-vingt-deux. Le modèle CRF a obtenu cinquante-cinq points en F1, tandis que les Représentations d'encodeurs bidirectionnels à partir de transformateurs multilingues ont obtenu quatre-vingt-deux, ce qui est une grande différence. Donc, une fois que nous avons eu ces résultats, nous nous sommes posés une autre question qui est : pourrions-nous trouver un modèle BiLSTM-CRF, l’alimenter avec différents types d’intégrations, des intégrations qui encodent différents types d’informations linguistiques, et dépasser les résultats obtenus par les modèles basés sur la conversion ? Donc, pour ce faire, nous avons effectué quelques expériences préliminaires ; nous avons exécuté ceci par le biais du modèle BiLSTM-CRF en utilisant la bibliothèque Flare. Et nous avons essayé d’expérimenter différents types d’intégrations comme celles basées sur la conversion, mais aussi des intégrations de caractères, de texte rapide et ainsi de suite. Ce que nous avons découvert, c’est que les intégrations basées sur la conversion ont obtenu de meilleurs résultats que les intégrations non contextualisées, et que la combinaison d’intégrations de Représentations d'encodeurs bidirectionnels à partir de transformateurs en anglais et de BETO en espagnol dépasse les intégrations de Représentations d'encodeurs bidirectionnels à partir de transformateurs multilingues. Et aussi, que les intégrations de BPE produisent un meilleur F1 et les intégrations de caractères, un meilleur rappel. Dans cet esprit, ce sont les meilleurs résultats que nous avons obtenus. Les deux modèles étaient des modèles BiLSTM-CRF utilisant Flare. L’un a été alimenté avec des intégrations de BETO, de Représentations d'encodeurs bidirectionnels à partir de transformateurs et de BPE, et l’autre avec des intégrations de BETO, de Représentations d'encodeurs bidirectionnels à partir de transformateurs, de BPE et aussi des intégrations de caractères. Ce dernier était celui qui a produit le score F1 le plus élevé sur l’ensemble de test, bien que le score le plus élevé sur l’ensemble de développement ait été obtenu par celui sans intégrations de caractères. Gardons juste à l’esprit que le meilleur résultat que nous avons obtenu avec Représentations d'encodeurs bidirectionnels à partir de transformateurs multilingues était un F1 de soixante-seize sur l’ensemble de développement et quatre-vingt-deux sur l’ensemble de test. C’est donc une amélioration comparée à ces résultats. Enfin, nous nous sommes posés une autre question qui était de savoir si la détection d’emprunt lexical pouvait être encadrée comme apprentissage par transfert de l’identification de langue dans l’alternance codique ? Nous exécutons alors le même modèle BiLSTM-CRF que nous avions exécuté en utilisant Flare, mais au lieu d’utiliser ces intégrations de BETO et Représentations d'encodeurs bidirectionnels à partir de transformateurs basées sur la conversion non adaptées, nous avons utilisé les intégrations d’alternance codique. Qu’est-ce que les intégrations d’alternance codique ? Eh bien, ce sont des intégrations qui ont été des intégrations basées sur la conversion ajustée, qui ont été préformées pour l’identification de langue sur la section anglaise espagnole des données d’alternance codique LinCE. LinCE est un ensemble de données sur l’alternance codique qui comporte une section sur l’anglais espagnol, l’alternance codique anglais espagnol. Nous avons donc alimenté notre BiLSTM-CRF avec des intégrations d’alternance codique et éventuellement des intégrations de caractères, des intégrations de BPE et ainsi de suite. Le meilleur résultat que nous avons obtenu était quatre-vingt-quatre points vingt-deux, ce qui est le plus élevé parmi tous les modèles que nous avons essayés sur l’ensemble de test. Bien que le meilleur score F1 que nous ayons obtenu sur l’ensemble de développement, qui était de soixante-dix-neuf, était inférieur au meilleur résultat obtenu par le BiLSTM-CRF alimenté avec des intégrations non adaptées. Voilà donc les conclusions de notre travail. Nous avons produit de nouvelles données de fil d’actualité espagnol qui sont annotées avec des emprunts lexicaux non assimilés. Ces données sont plus denses en matière d’emprunt et riches en OOV par rapport aux ressources antérieures. Nous avons exploré quatre types de modèles pour la détection d’emprunt lexical. Hum. En termes d’analyse des erreurs, eh bien, le rappel était un point faible pour tous les modèles. Ah, comme vous pouvez le voir ici, certains faux négatifs fréquents incluent des emprunts en majuscules, des mots qui existent à la fois en anglais et en espagnol, par exemple. Il est également intéressant de noter que les intégrations de BPE semblent améliorer le score F1. Et l’intégration de caractères semble améliorer le rappel. Ce qui est une découverte intéressante que peut-être nous pouvons explorer sur les travaux futurs. Hum. Eh bien, c’est tout ce que j’ai. Merci beaucoup pour votre écoute. Je m’appelle Antoine. Je suis doctorant à l’Université du Massachusetts à Amherst. Je vous présente notre article KinyaBERT : un modèle de langue en kinyarwanda conscient de la morphologie. Aujourd’hui, je vais parler de la motivation pour ces recherches. Ensuite, je présenterai en détail l’architecture du modèle KinyaBERT. Je parlerai ensuite de nos résultats expérimentaux, puis je terminerai par quelques conclusions. Nous savons tous que les progrès récents du traitement du langage naturel ont été rendus possibles par l’utilisation de modèles de langues préformées tels que les Représentations d'encodeurs bidirectionnels à partir de transformateurs. Cependant, il y a encore un certain nombre de limitations. En raison de la morphologie complexe qui est exprimée par la plupart des langues morphologiquement riches, l’algorithme de marquage byte pair encoding omniprésent que j’ai utilisé ne peut pas extraire les unités lexicales sous-mots exactes, signifiant les morphèmes, qui sont nécessaires pour une représentation efficace. Par exemple, ici, nous avons trois mots en kinyarwanda ayant plusieurs morphèmes en eux, mais les algorithmes de BPE ne peuvent pas les extraire. En effet, certaines règles morphologiques produisent différentes formes de surface qui cachent l’information lexicale exacte, et le BPE, qui est uniquement basé sur les formes de surface, n’a pas accès à ce modèle lexical. Le deuxième défi est que même si l’on avait accès à un analyseur morphologique oracle, remplacer les gages de BPE par des morphèmes n’est pas suffisant pour exprimer la compositionnalité morphologique. Une troisième lacune dans les recherches est que les nouveaux modèles de langue préformée sont le plus souvent évalués sur des langues à ressources élevées. Et nous devons évaluer leur applicabilité sur des ressources faibles et diverses langues également. Par conséquent, nous présentons KinyaBERT, qui est une adaptation simple mais efficace de l’architecture des Représentations d'encodeurs bidirectionnels à partir de transformateurs destinée à gérer plus efficacement les langues morphologiquement riches. Nous évaluons KinyaBERT sur le kinyarwanda, une langue low resource riche morphologiquement, qui est parlée par plus de douze millions de personnes à travers l’Afrique de l’Est et centrale. La saisie du modèle est soit une phrase, soit un document. Par exemple, ici, nous avons John twarahamubonye biradutangaza, qui signifie « nous avons été surpris de trouver John là-bas ». Comme vous pouvez le voir, les mots en kinyarwanda comprennent plusieurs morphèmes qui renferment différentes informations. Par conséquent, dans notre modèle, nous faisons passer cette phrase ou un document à un analyseur morphologique. Ce qui engendre alors des morphèmes contenus dans chacun des mots. Les morphèmes sont généralement constitués du radical et de zéro ou plus d’affixes. Les affixes peuvent indiquer le temps, l’aspect, le sujet ou l’objet dans les verbes, et se rapportent plus souvent à la classe nom bantoue pour les sujets et les objets. L’analyseur morphologique produit également une étiquette de partie de discours pour chacun des mots. Après cette étape, nous faisons des intégrations pour le dis- pour les étiquettes de la partie de discours. Intégrations pour les affixes. Et intégrations pour le radical. Il s’agit du niveau morphologique ; il s’agit des intégrations de niveau morphologique. Nous faisons ensuite passer ces intégrations à travers un encodeur morphologique, qui est un petit encodeur de conversion appliqué à chaque mot indépendamment. Les résultats sont les vecteurs contextualisés avec les informations morphologiques à chaque mot. Maintenant, nous effectuons une composition où les intégrations morphologiques correspondant à une partie de discours et au radical sont concaténées ensemble. Nous les concaténons en outre avec une autre intégration du radical au niveau de la phrase. Ensuite, nous formons une saisie à la phrase principale ou l’encodeur de document. Le résultat final donne des intégrations contextualisées qui peuvent être utilisées pour les tâches de TAL traitement automatique du langage naturel downstream. Pour un analyseur morphologique, nous utilisons des principes de morphologie à deux niveaux à états finis avec une mise en œuvre personnalisée adaptée à la langue kinyarwanda. Nous modélisons efficacement la morphologie de tous les mots en kinyarwanda, y compris les verbes, les noms, les pronoms démonstratifs et possessifs, les chiffres et autres. Nous utilisons une partie non supervisée d’algorithme de classification de discours. Un modèle factorisé de premier ordre est utilisé pour rendre compte de la probabilité morphologique, essentiellement la probabilité attribuée par l’analyseur morphologique. Nous prenons également en considération la priorité de l’étiquette de la partie de discours ainsi que les accords syntaxiques qui sont présents dans les mots de saisie. Le marqueur de partie de discours utilise une inférence bidirectionnelle bidi qui améliore le plus souvent l’algorithme Viterbi utilisé pour le décodage. Quelques remarques ici pour l'encodage positionnel. Premièrement, l’encodeur morphologique n’utilise aucun encodage positionnel. C’est parce que chacun des morphèmes occupe un emplacement connu dans le modèle morphologique. Par conséquent, l’information positionnelle est inhérente lorsque les morphèmes sont donnés. Deuxièmement, l’encodeur de phrase utilise les intégrations positionnelles relatives dites non liées, qui ont été récemment publiées lors de la conférence ICLR. Ces intégrations positionnelles démêlent essentiellement les corrélations positionnelles de calcul d’attention gage à gage. De manière similaire aux Représentations d'encodeurs bidirectionnels à partir de transformateurs, nous utilisons un objectif de préformation de modèle de langue masqué. Essentiellement, nous devons prévenir à la fois le radical et les affixes qui sont associés aux mots. Pendant la préformation, quinze pour cent de tous les mots sont considérés pour la prévention, dont quatre-vingt pour cent sont masqués, dix pour cent sont échangés avec des mots aléatoires et dix pour cent sont laissés inchangés. Pour la prévention d’affixe, nous faisons face à un problème de classification multi-étiquettes. Pour cela, nous regroupons les affixes ensemble dans un nombre fixe d’ensembles et prévenons l’ensemble comme une étiquette de classe. Ou bien, l’autre option est de prévenir le vecteur de probabilité d’affixe. Nous évaluons ces deux approches dans nos expériences. Nous préformons KinyaBERT sur environ deux giga-octets et demi de texte kinyarwanda, et le comparons à trois modèles de base. L’un est un modèle multilingue appelé XLM-R, qui est formé sur un grand corpus de texte composé de plusieurs langues. Les deux autres bases sont préformées sur le même texte kinyarwanda en utilisant soit l’algorithme de byte pair encoding, soit l’analyse morphologique sans utiliser l’architecture encodeur de conversion à deux niveaux. Tous les modèles sont configurés dans l’architecture de base, qui est d’environ cent à cent et dix millions de paramètres, avec le kinyarwanda avec KinyaBERT utilisant le plus petit nombre de paramètres. Tous les modèles sauf les multilingues sont préformés pour trente-deux mille mises à jour de pentes avec une taille de lot de deux mille cinq cent soixante séquences dans chaque lot. Nous évaluons les modèles préformés sur trois ensembles de tâches. L’une est la référence GLUE qui a souvent été utilisée pour évaluer l’efficacité des modèles de langue préformée. Nous obtenons nos données de référence GLUE en traduisant les données de référence originales en kinyarwanda à l’aide de Google Translate. La deuxième tâche est la référence de reconnaissance d'entité nommée kinyarwanda, qui est un ensemble de données de haute qualité ayant été annoté par des locuteurs natifs formés. La troisième est une tâche de catégorisation des actualités où nous extrayons des articles de actualités de plusieurs sites web et collectons leurs étiquettes de catégorisation qui ont été attribuées par les auteurs, puis essayons essentiellement de prévenir ces dernières, les mêmes catégories. Et maintenant, passons aux résultats. Pour la référence GLUE, nous constatons que KinyaBERT dépasse systématiquement les modèles de référence. Ici, nous montrons la performance moyenne pour dix cycles de raffinement. Nous effectuons également une évaluation des traductions produites par Google Translate. Essentiellement, les utilisateurs ont évalué environ six mille exemples, en attribuant des scores sur une échelle de un à quatre et en évaluant la qualité des traductions. Le résultat est que beaucoup de traductions étaient bruyantes. Mais tous les modèles ont dû faire face au même bruit de traduction, et la performance relative entre les modèles est toujours importante à remarquer. Pour la tâche de reconnaissance d'entité nommée, nous constatons également que KinyaBERT fournit les meilleures performances avec la variante de régression de distribution d’affixes fonctionnant le mieux. Ces résultats sont également des moyennes de dix cycles de raffinement. Pour la tâche de catégorisation des actualités, nous trouvons des résultats mitigés. Le travail antérieur sur la classification de texte pour le kinyarwanda avait trouvé que la détection de mot-clé simple est surtout suffisante pour résoudre cette tâche spécifique. Par conséquent, il y a moins d'avantage à utiliser des modèles de langue préformée. Sur cette tâche particulière de catégorisation des actualités. Nous avons également mené une étude d’ablation pour voir s’il existe des structures alternatives qui améliorent les performances. Pour la référence GLUE, nous constatons que l’utilisation d’ensembles d’affixes donne constamment de meilleurs résultats, tandis que l’objectif de régression de probabilité d’affixe fournit les meilleures performances sur la reconnaissance d'entité nommée. De plus, en examinant les faibles scores pour le raffinement, nous constatons que KinyaBERT a une meilleure convergence dans la plupart des cas. Donc, pour conclure, ce travail a démontré l’efficacité de l’utilisation explicite des informations morphologiques dans les modèles de langue préformée. L’architecture à deux niveaux proposée permet de capturer la compositionnalité morphologique de la complexité morphologique, qui est un aspect important des langues morphologiquement riches. Ces résultats devraient motiver davantage les recherches sur les modèles de langue préformée conscients de la morphologie. Bonjour, je m’appelle Michal Pietruszka et j’ai le plaisir de vous présenter l’article intitulé Modèles de conversion parcimonieux avec la mise en commun de la représentation adaptative. Un travail réalisé à Applica intelligence artificielle en coopération avec Lukasz Borchmann et Lukasz Garncarek. Permettez-moi de commencer par les problèmes que nous visons dans le cadre de notre travail. Notre méthode fonctionne bien pour les cas où de longues saisies sont considérées. En gros, c’est pour les ordres de tâche et de saisie de plus de deux mille gages, et les cibles sont plus courtes que les saisies fournies. Cela a des applications spécifiques en TAL traitement automatique du langage naturel. Par exemple, on peut imaginer qu’étant donné qu’un document est long, il est nécessaire de le résumer, de classer, de répondre à la question à ce sujet et d’extraire des informations ou certaines expressions clés. Permettez-moi de rappeler la conversion vanille et sa question de sa complexité d’attention qui dépend du carré de la ligne de saisie. Dans la conversion vanille, avec une connectivité de pleine attention, les relations de chaque gage à chaque autre gage doivent être calculées. La complexité informatique de l’attention, qui dépend du nombre de couches l, de la longueur de séquence n, d’une autre longueur de séquence et de la dimensionnalité des représentations. De même, dans l’attention croisée du décodeur, à cette image sur le côté droit, la seule différence ici est que les gages cibles sont attentifs aux gages de saisie dans ce cas. Ce que l’on retrouve également dans cette formule. Le score BLEU représente les relations qui doivent être calculées. Dans le cas de la pleine attention, nous devons calculer toutes les relations dans la séquence de saisie. Maintenant, nous voyons ce qui se passe lorsque nous avons un encodeur par bloc qui fonctionne en limitant la connectivité des gages afin qu’ils ne puissent voir que les autres gages à proximité. Le texte est lu en morceaux, ce qui peut réduire considérablement le nombre de calculs du côté de l’encodeur, mais n’améliore pas l’attention croisée du décodeur car chaque gage de saisie est de toute façon transmis au décodeur. Cette méthode est souvent appelée fusion dans le décodeur. L’amélioration ici peut être interprétée comme changeant l’une des dépendances de n en une autre constante m représentant la taille du bloc. Notre observation clé est que la plupart des gages ne sont pas pertinents pour une grande variété de tâches et peuvent être presque complètement ignorés. Ceci est illustré sur la diapositive. Les seules parties des saisies sont pertinentes pour la sortie souhaitée. Par exemple. On peut lire un article une fois en marquant les parties les plus importantes avec un surligneur, puis produire un résumé basé sur cette partie à partir du stade intermédiaire seulement. Le coût de la mise en surbrillance et de la décision de savoir si le gage actuel est essentiel pour produire le résumé est donc peu élevé et ne dépend que de la représentation du gage. La mise en commun des gages en surbrillance est possible. Grâce à notre meilleur opérateur k, son coût est négligeable. Le coût de production d’un résumé à partir d’une saisie raccourcie est également beaucoup plus faible que dans le modèle vanille lorsque la saisie complète est prise en compte. Mais une question se pose. Comment sélectionner les gages importants et rétropropager les pentes vers cette sélection ? Le problème sous-jacent essentiel que nous résolvons est de proposer le mécanisme de sélection adaptatif. Celui qui peut permettre à la pente de se rétropropager pendant la formation afin que le réseau puisse apprendre à sélectionner les gages les plus importants. Plus précisément Compte tenu de certains soulignements d’intégrations obtenus à partir d’une couche linéaire simple, la tâche est de renvoyer les intégrations au score le plus élevé. Tout d’abord, la séquence est permutée et les paires sont préparées de manière à ce que le vecteur de score le plus élevé soit pris avec le vecteur de score le plus faible. Ensuite, les poids sont calculés à l’aide de softmax boosté sur les scores. Après chaque tour de tournoi, de nouveaux vecteurs et scores sont composés comme une combinaison linéaire de ces paires avec les poids obtenus. Donc, en bref, nous les combinons linéairement en effectuant un softmax sur leurs scores. Et tout en combinant deux gages, un certain bruit peut être produit. Mais cela permet aussi de propager les pentes à toutes les intégrations de saisie. En bref, un top k adaptatif que nous proposons est basé sur l’exécution d’un tournoi comme la sélection souple à chaque étape. Et d’un point de vue différent, la mise en commun de la représentation suit la couche de l’encodeur. Tout d’abord, chaque représentation est notée, puis seules celles qui ont les scores les plus élevés sont passées à la couche suivante. L’encodage peut être effectué comme dans l’architecture de conversion standard sur la saisie pleine longueur. Il est cependant possible de traiter le texte par blocs de longueur fixe et de sélectionner globalement la meilleure représentation. Voici un exemple de la mise en commun de représentation introduite après l’encodeur. Cela a directement influencé la cause de l’attention croisée, qui ne dépend pas de la longueur de saisie N, mais de la constante K, représentant la longueur mise en commun. Cette constante indique combien de représentations sont sélectionnées et transmises au décodeur. Produire un résumé à partir d’un texte plus court est nettement moins cher que la solution antérieure. Comme la longueur de séquence qui peut être raccourcie par un grand facteur. Par exemple, nous avons utilisé avec succès le k seize ou même soixante-quatre fois plus petit que la valeur de n dans nos expériences. Veuillez noter que l’impact bénéfique de l’encodage par blocs et de l’attention personnelle est maintenu. Rappelez-vous que le coût informatique de l’attention dépend du carré de la longueur de saisie. Réduire plus tôt la saisie pendant le processus d’encodage peut baisser considérablement les coûts. Pour le modèle pyramidion, nous avons réduit la taille de la représentation sur la sortie de chaque couche choisie, conduisant à la réduction exponentielle du coût informatique au fur et à mesure que l’encodage progresse. Comme vous pouvez le voir, le coût informatique total d’un encodeur complet est ici moins de deux fois le coût de la première couche pleine grandeur. Lorsque la mise en commun est introduite plus tôt, la somme de tous les carrés violets est donc liée à une constante, qui ne dépend pas du nombre de couches l. Mais sur la constante c, qui peut être influencée par le placement des couches de mise en commun au sein du réseau. Nos améliorations ont été évaluées sur la base de huit mille longues saisies de gages. Et la figure montre que lorsque la mise en commun est engagée, la meilleure évolutivité pour la profondeur du réseau est atteinte. Ici, on peut noter que la formation du pyramidion de vingt-quatre couches peut être moins chère que la formation d’une conversion vanille à deux couches sur des saisies aussi longues. Sans parler de la facilité avec laquelle la conversion vanille peut perdre la mémoire pour une si longue saisie. La comparaison qual qualité qual qualitative de notre pyramidion tendance à d’autres bases est effectuée sur la longue tâche de synthèse de document, ou compte tenu du corps d’un article d’arXiv ou PubMed, la tâche est de générer son résumé. Ainsi, on peut voir bloc par bloc, qui est notre base, ce qui est effectué au niveau du re, les modèles ultra-modernes récents, tandis que le pyramidion conserve ou améliore la performance de cette base compétitive. En même temps, notre modèle est quatre-vingts pour cent plus rapide à former et plus de quatre cent cinquante pour cent plus rapide à l’inférence quand il est comparé à la base par bloc. Les deux modèles ont un nombre de paramètres beaucoup plus faible et ont été formés à partir de zéro sur les tâches choisies. Les approches antérieures visant à atteindre un rendement similaire devaient utiliser plus de paramètres et tirer parti des modèles fondamentaux de base préformés, ainsi que de l’objectif de préformation en langue supplémentaire pour atteindre un rendement similaire. Nous vous invitons à lire notre article complet et à utiliser notre code GitHub. Merci d’avoir regardé cette vidéo. Bonjour, je m’appelle Jiawei Zhou de l’Université d’Harvard. Je suis très heureux de présenter notre travail sur l’analyse syntaxique et sémantique en ligne pour la réduction de la latence dans le dialogue orienté sur la tâche. Il s’agit d’un travail commun avec Jason, Michael, Anthony et Sam de Semantic Machines par Microsoft. Dans le dialogue orienté sur la tâche, un utilisateur interagit avec le système qui traite les discours de l’utilisateur énoncés généralement en parlant. De la fin du discours de l’utilisateur à la réponse du système, il y a souvent un retard notable. Sous le capot, le discours de l’utilisateur est traduit en un programme exécutable. Celui-ci est ensuite exécuté afin que le système puisse répondre correctement. Parce que le programme est représenté comme un graphique sémantique qui décrit le calcul, où le nodule représente une invocation de fonction et ses enfants sont les arguments. Les grands nodules marquent des opérations instantanées, mais les autres mettent du temps à s’exécuter. Dans l’exemple simple que nous montrons ici, ces programmes peuvent souvent être des graphiques plus compliqués au-delà des structures arborescentes. Dans cette conférence, nous posons la question : pouvons-nous commencer à générer le programme et à l’exécuter avant même que l’utilisateur ait terminé le discours, afin que le système puisse obtenir une réponse plus rapide ? C’est la prévention en ligne et le problème de décision. Il y en a beaucoup d’autres dans ce domaine. Les exemples incluent la traduction simultanée où un interprète en direct traduit une langue en une autre en temps réel, la saisie automatique intelligente du texte pour deviner l’intention de l’utilisateur, et Uber pool où les chauffeurs sont envoyés là où ils pourraient être nécessaires en fonction de la demande prévue. Tous ces scénarios ont une chose en commun. C’est-à-dire qu’il est bénéfique de prendre des décisions avant de voir toutes les saisies. Dans notre cas, nous allons traiter de l’analyse syntaxique et sémantique en ligne, ce qui pourrait être difficile car nous devons deviner ce que l’utilisateur pourrait dire. Et cela est également sous-exploré sans indicateur d’évaluation formel. Tout d’abord, regardons comment fonctionne un système ordinaire. Il fonctionne hors ligne par l'analyse syntaxique du programme uniquement à la fin du discours de l’utilisateur. Ici, le graphique de caractères est prévenu après avoir vu toutes les informations. En revanche, nous proposons un système en ligne qui compare à chaque préfixe de discours. Par exemple, chaque fois que nous voyons un nouveau gage, nous prévenons un nouveau graphique. Notez qu’il peut y avoir des erreurs. À l’emplacement de la pool party avec Barack Obama, nous avons obtenu un graphique avec les bons nodules sur la personne et le sujet d’activité, mais deviné les mauvaises informations de timing. Ce processus se poursuit jusqu’à ce que nous recevions le discours complet de l’utilisateur. Comment cela affecterait-il la chronologie d’exécution dans le système hors ligne ? Nous obtiendrons le graphique de programme à la fin afin que le système puisse commencer l’exécution à ce stade. Rappelez-vous que les grands nodules sont des opérations rapides ; nous ne considérons donc que la chronologie d’exécution des fonctions lentes colorées. Premièrement, ces deux fonctions Trouver une personne peuvent être exécutées en parallèle, surlignées en blanc à partir de la case rose car elles n’ont pas de dépendance à d’autres fonctions. Ensuite, l’activité de création de nodules peut ensuite être exécutée après avoir obtenu des résultats à partir de nodules de niveau inférieur, puis la fonction supérieure mène à l’achèvement de l’ensemble du programme. Le processus d’exécution est strict, limité à la structure de dépendance du programme où certaines opérations ne peuvent pas être parallélisées, ce qui induit un retard notable. Dans notre système en ligne, où nous prévenons au fur et à mesure, l’exécution du programme peut commencer plus tôt. Ici, au préfixe après Obama, nous prévenons en toute confiance que la fonction Trouver une personne devrait être dans le programme, mais le reste peut contenir des erreurs car elles sont grisées. L’exécution du nodule peut être immédiatement commencée comme une étape. Ensuite, avec plus de gages, nous prévenons un graphique totalement nouveau, mais une partie est déjà en cours d’exécution. Donc, nous n’avons qu’à considérer le reste des nodules sur lesquels nous sommes confiants. Ici, une autre fonction Trouver une personne peut être exécutée en parallèle. Encore une fois, nous pouvons avoir des préventions erronées. Avec plus de texte, nous avons plus de capacité à faire les choses correctement. Comme l’heure de l’activité ici où AM est également anticipé correctement. Ensuite, nous pouvons commencer à exécuter le reste en suivant la structure de dépendance du programme. En chevauchant la chronologie d’exécution avec la chronologie du discours, nous gagnons beaucoup de temps. Nous avons donc proposé la tâche d’analyse syntaxique et sémantique en ligne. Une hypothèse sous-jacente est que le temps d’exécution domine le temps de prévention du modèle. Donc, nous ne pouvions gagner du temps qu’en prévenant plus tôt. Une autre hypothèse est que, comme la prévention et l’exécution se produisent en arrière-plan, cela n’est pas visible par les utilisateurs. Il n’est pas nécessaire de maintenir un historique d’analyse syntaxique cohérent. Donc, nous réanalysons à partir de zéro après chaque gage. En particulier, nous proposons une approche en deux étapes. Une étape proposée qui prévient un graphique avec une structure complète et une étape de sélection qui sélectionne les nodules valant la peine d’être exécutés pour le moment. Nous avions deux variantes de la méthode proposée. La première approche combine l’achèvement d’un modèle de langue avec un discours complet à analyse syntaxique de graphique. En particulier, le préfixe après Obama est d’abord complété par un modèle de langue BART raffiné, puis traduit en un programme avec un analyseur hors ligne complet. La seconde approche prévient directement le programme à partir des préfixes de discours de l’utilisateur. Ceci est réalisé en formant un seul analyseur en ligne à traduire au graphique objectif à partir de chaque préfixe. Cela facilite au modèle l’apprentissage de la bonne anticipation. Avec un peu plus de détails, comment générons-nous ces graphiques ? Nous formulons le problème en générant une version série du graphique. Chaque nodule ou arête est représenté(e) par une action. Ici, nous commençons par le premier nodule. Le nombre ci-dessous enregistre l’indice absolu dans l’historique des actions. Ensuite, nous avons le deuxième nodule. Ensuite, il y a l’arête entre eux. Il contient le pointeur vers l’indice du nodule antérieur et l’étiquette d’arête. Zéro signifie ici connecter le nodule le plus récent avec le nodule généré par l’action zéro, le nodule suivant et l’arête suivante. Ce processus se poursuit jusqu’à ce que nous générions le graphique complet. Le modèle sous-jacent est basé sur un transformateur avec un mécanisme de pointage automatique similaire à un analyseur basé sur la transition antérieure. Après avoir généré un graphique complet, nous avons obtenu les probabilités de niveau d’action qui correspondent aux différentes parties du graphique. Nous sélectionnons des sous-graphiques de confiance en fonction de l’heuristique de seuillage à exécuter. Plus tard, nous allons modifier le seuil pour obtenir différents compromis entre la réduction de la latence et le coût d’exécution. Pour une évaluation formelle des méthodes en ligne, nous proposons une réduction finale de la latence ou un indicateur FLR. Voici un récapitulatif de la façon dont un système hors ligne termine la chronologie d’exécution. Dans les systèmes en ligne, l’exécution chevauche la chronologie de discours ; donc elle se termine plus tôt. FLR est défini comme le temps de réduction comparé au système hors ligne, marqué par la fin de l’exécution. Nous menons des expériences sur deux grandes données d’analyse syntaxique et sémantique conversationnelle, SMCalFlow et TreeDST. Notre analyseur basé sur le graphique, lorsqu’il fonctionne hors ligne, atteint des performances de pointe sur l’analyse syntaxique sur les deux données. Le modèle complet de LM réalise également un gain BLEU non trivial comparé à la simple base de l’achèvement du nodule. Examinons maintenant la précision de prévention de notre préfixe pour l’analyseur de graphique. Nous testons le score F1 de correspondance des tuples de graphique entre la génération et le graphique dans les données de validation dans l’axe y pour chaque longueur de préfixe, et dans l’axe x représenté par des pourcentages. Chacune de ces courbes représente un modèle différent avec la seule différence de données de formation. La courbe du bas est l’analyseur hors ligne, et nous mélangeons les données de préfixe en différentes longueurs pour faire passer le modèle à un analyseur en ligne. Par exemple, le préfixe de légende quatre-vingts pour cent plus signifie que le modèle est formé avec les données de préfixe ayant une longueur de préfixe supérieure à quatre-vingts pour cent de la longueur totale du discours. Le coin supérieur gauche est la zone souhaitée. Comme nous pouvons le voir, l’analyseur hors ligne en courbe noire ne se porte pas bien sur les données de préfixe. Comme nous mélangeons plus de préfixes dans la formation, la courbe se soulève en haut à gauche, en étant plus performante sur toutes les longueurs de préfixe. Cependant, la performance complète d’analyse syntaxique du discours n’est pas affectée dans le point supérieur droit. Sur la base de ces résultats solides, combien de latence réduisons-nous ? Nous mesurons le temps par le nombre de gages sources et simulons différents temps d’exécution de fonction. Les courbes montrent le compromis entre l’indicateur FLR et le coût d’exécution, mesuré par le nombre de coûts de fonction excessifs qui ne sont pas corrects. Ceci est réalisé en faisant varier le seuil de sélection du sous-graphique. Un seuil plus élevé sélectionne moins de fonctions d’erreur, mais obtient un FLR plus petit, tandis que le seuil inférieur sélectionne et exécute les programmes de manière plus agressive. Nous comparons les deux approches que nous proposons et une base qui ne fait rien d’autre que d’appliquer directement l’analyseur hors ligne pour l’utilisation en ligne. La région supérieure gauche a le meilleur compromis FLR et coût. Nous voyons nos deux méthodes battre la ligne de base par une grande marge, et elles fonctionnent de manière plus similaire sur TreeDST. Bien que l’exécution des fonctions individuelles soit plus rapide, cela tend à y avoir plus d’exécutions lancées et une marge de réduction de la latence plus faible. Lorsque l’exécution des fonctions individuelles est plus lente, il y a plus de marge pour l’amélioration du FLR. Nos deux approches permettent d’obtenir de meilleurs résultats dans différentes régions de coûts. Dans l’ensemble, nous obtenons une réduction de latence relative de trente à soixante-trois pour cent en fonction du temps d’exécution et du coût autorisé. Enfin, nous avons une répartition de la réduction de latence moyenne en gages pour chaque type de nodule de fonction lorsque le coût autorisé est de trois exécutions. Comme nous pouvons le voir, il y a des gains partout. Il y a aussi certaines fonctions sur lesquelles nous obtenons une réduction de latence impressionnante où la barre rouge est beaucoup plus longue, comme trouver le gestionnaire et le destinataire. Ce sont des fonctions de bas niveau qui n’ont pas beaucoup de dépendance des autres. En conclusion, nous avons proposé une analyse syntaxique et sémantique en ligne comme nouvelle tâche à explorer avec l’indicateur rigoureux de réduction de la latence. Avec un analyseur sémantique basé sur le graphique fort, nous obtenons une réduction de latence relativement bonne soit par notre approche pipeline avec l’achèvement du LM et un analyseur complet, soit directement par un analyseur appris sur les préfixes. De plus, notre approche peut être un cadre général et être appliquée à d’autres représentations sémantiques exécutables dans différents domaines. Les travaux futurs pourraient explorer la méthode d’intégration de prévention et d’exécution plus intelligente. Merci de votre attention. Bonjour. Je vais discuter de notre travail sur la génération de contrefactuels améliorés d’extraction pour les tâches de réponse aux questions. C’est le travail effectué lors de mon stage chez le centre de recherches Google, où j’ai été encadré par Matthew Lamm et Ian Tenney. Pour motiver la tâche, permettez-moi de commencer par définir un contrefactuel. Dans ce travail, nous définissons un contrefactuel comme une perturbation du texte de saisie qui diffère d’une manière contrôlée significative du texte original. Et cela nous permet de raisonner sur les changements dans le résultat ou l’étiquette de tâche. Par exemple, changer les mots fascinants en captivants ou supposés abrutissants change le sentiment pour cette critique de film. De même, l’ajout du qualificatif féminin à la question modifie la réponse à la question dans l’exemple ci-dessous. Les humains sont généralement robustes à de telles perturbations comparés aux modèles de TAL traitement automatique du langage naturel formés sur la tâche. Pourquoi ça ? Les données peuvent être échantillonnées avec des biais systématiques qui conduisent à une limite de décision simple violée par le contrefactuel. Comme le montre ce problème de classification 2D. Mon travail a révélé que l’ajout d’exemples contrefactuels aux données de formation peut rendre le modèle robuste à de telles perturbations. Donc, si les contrefactuels sont précieux, comment pouvons-nous les générer ? Cette tâche est particulièrement difficile pour le TAL traitement automatique du langage naturel car il y a ici trois exemples de trois tâches de TAL traitement automatique du langage naturel différentes. Comme vous pouvez le voir, les exemples qui violent la limite de décision entre les résultats doivent être très soigneusement élaborés en perturbant certains attributs du texte qui sont soulignés ici. Cela pourrait être fait par annotation civique, mais cela est coûteux et partial. Certains travaux antérieurs se sont concentrés sur l’utilisation d’arbres de syntaxe ou d'étiquetage de rôle sémantique. Mais l’ensemble des perturbations générées par ces techniques sont limitées par le cadre sémantique. Des travaux plus récents ont utilisé des modèles de langue masqués pour remplir des parties masquées du texte afin de changer les étiquettes. Mais trouver quelles parties du texte perturber peut être difficile. Il y a plus de défis à générer des contrefactuels pour la réponse aux questions spécifiquement. Cette tâche nécessite des connaissances de base. Par exemple, pour perturber la question originale : est-ce qu'Indiana Jones et le Temple maudit est une préquelle ? Nous devons être au courant des autres films de la franchise pour arriver à une question comme : est-ce qu’Indiana Jones et les Aventuriers de l'arche perdue est une préquelle ? En outre, des perturbations aléatoires peuvent conduire à des questions qui ne répondent pas avec les preuves disponibles ou ont de fausses prémisses. De plus, certaines perturbations de question peuvent conduire à une dérive sémantique significative par rapport à la saisie originale. Par exemple, est-ce qu’Indiana Jones pratique l’esclavage des enfants dans le Temple maudit ? Nous proposons une technique très simple mais efficace appelée Retrieve Generate Filter ou RGF, pour s’attaquer aux perturbations contrefactuelles des questions, et qui vise également à relever tous les autres défis susmentionnés. L’intuition de base derrière le RGF est que les informations d’arrière-plan nécessaires pour générer des perturbations peuvent être présentes dans les quasi-accidents causés par un modèle de réponse aux questions. Par exemple, le modèle REALM à la fine pointe de la technologie produit les premières réponses k suivantes à la question : qui est le capitaine du Richmond Football Club ? Bien qu’il récupère le passage de référence original et répond Trent Cotchin en premier choix. Il extrait également des passages et des réponses supplémentaires qui peuvent être utilisés pour guider la perturbation de question. Par exemple, il récupère deux autres réponses correspondant aux capitaines de l’équipe de réserve et de l’équipe féminine du même club, ce qui peut conduire à des modifications intéressantes. Pour résumer, le RGF extrait d’abord les premières réponses k les plus pertinentes et les contextes qui ne correspondent pas à la réponse de référence dans le contexte. Suite à cette étape, le modèle de production de questions conditionne ces réponses alternatives pour générer une question qui leur correspond. Et enfin, nous pouvons filtrer les questions générées en fonction de la minimalité ou du type de perturbation sémantique que nous voulons introduire. En passant en revue chaque étape plus en détail pour l’extraction, nous utilisons un modèle lu comme REALM qui prend comme saisie la question originale, et un grand corpus comme Wikipédia. Il est constitué de deux modules. Le module d’extraction effectue des recherches de similarité sur un indice dense de passages pour extraire les passages k les plus pertinents à la question. Et un module de lecture extrait ensuite un étendage de chaque passage en tant que réponse potentielle. REALM extrait le passage d’or et la réponse dans la plupart des cas. Cependant, dans ce travail, nous sommes plus intéressés par les réponses et le contexte qu’il extrait plus loin dans la ligne. Dans l’étape suivante, production de questions, nous utilisons ces réponses alternatives et contextes pour générer de nouvelles questions qui correspondent à ces alternatives. Le modèle de production de questions est une conversion texte-à-texte préformé qui est raffiné sur les données NQ pour générer une question pour une réponse marquée dans le contexte. Au cours de l’inférence, nous fournissons le modèle de production de questions, la réponse alternative et le contexte que nous avons extraits à l’étape antérieure. Par exemple, pour la question : qui est le capitaine du Richmond Football Club ? REALM extrait des passages sur l’équipe féminine du club, dirigée par Jess Kennedy, et le modèle de production de questions génère la requête « qui a été le capitaine de la toute première équipe féminine du Richmond Football Club ? » Qui a une perturbation sémantique spécifique. D’une manière similaire, nous recevons également des questions comme : qui était capitaine de l’équipe de réserve VFL de Richmond ? Ou qui Graham a-t-il invalidé lors de la grande finale l’année dernière ? Enfin, nous filtrons un sous-ensemble des requêtes générées en fonction de certaines caractéristiques souhaitées. Comme motivé plus tôt, nous aimerions nous assurer que la nouvelle question est toujours sémantiquement proche de l’originale. Pour les techniques de filtrage qui ne nécessitent pas de supervision supplémentaire, nous conservons simplement de nouvelles questions qui ont une petite distance d’édition de l’étiquette de gage par rapport à la question d’origine. Par exemple, nous supprimons la question : qui Graham a-t-il invalidé lors de la grande finale l’année dernière ? Car elle a une distance d’édition plus longue par rapport à la question d’origine. Dans nos expériences, nous démontrons que cette heuristique simple peut être utilisée pour améliorer et mettre en file d’attente les données de formation. Nous expérimentons également une stratégie de filtrage basée sur le type de perturbation sémantique. À cette fin, nous utilisons un cadre de décomposition de requête à usage général appelé QED. QED identifie deux parties à la question, un prédicat et une référence. Les références sont des syntagmes nominaux dans la question qui correspondent à des entités dans le contexte. Un prédicat est essentiellement la partie restante de la question. Par exemple, nous sommes en mesure de décomposer la requête « qui a dirigé la toute première équipe féminine de Richmond en deux références » : l’équipe féminine du Richmond Football Club et le prédicat qui a dirigé X. Un modèle formé sur les annotations du prédicat de référence pour NQ nous fournit cette décomposition de question. La décomposition à la fois de la question originale et générée basée sur QED nous permet de catégoriser nos contrefactuels générés pour l’évaluation. Plus précisément, nous obtenons deux groupes de questions. Ceux qui subissent un changement de référence tout en conservant les prédicats, et ceux qui subissent un changement de prédicat et ajoutent éventuellement des références. Par exemple, qui a été capitaine de l’équipe de réserve de Richmond VFL est-il un changement de référence ? Alors que, qui porte le numéro neuf pour le club est un changement de prédicat. Nous évaluons maintenant l’efficacité des perturbations RGF lorsqu’elles sont améliorées par rapport aux données de formation. Ainsi, pour évaluer efficacement l’efficacité de l’élargissement contrefactuel en particulier, nous expérimentons deux bases de forte amélioration de données. La première base, appelée réponse aléatoire et production de questions, ajoute des données qui n’ont pas de relation avec la question originale. Autrement dit, les passages et les réponses sont simplement échantillonnés au hasard à partir de Wikipédia. Cette base ajoute essentiellement plus de données ressemblant à NQ. Avec la deuxième réponse d’or de base et la production de questions, nous mettons spécifiquement à jour la partie extraction de notre méthode. Ici, les réponses alternatives sont simplement choisies à partir du même passage qui contenait la réponse d’or. Comment l’élargissement des bases et du RGF fonctionne sur la reading comprehension où le modèle a accès à la question et au contexte ? Nous expérimentons avec six données hors domaine et présentons les résultats ici, où les données qui sont les training data sont doublées dans l’élargissement. Nous constatons que les deux bases d’amélioration de données ne sont pas en mesure d’améliorer notre généralisation du domaine. En effet, un ensemble de six modèles formés sur les données originales semble être la base la plus compétitive. En comparant avec cette base, nous constatons que les contrefactuels RGF sont capables d’améliorer les performances hors domaine tout en maintenant les performances de domaine. Cela suggère que combler les lacunes de raisonnement du modèle via l’élargissement contrefactuel est plus efficace que d’ajouter plus de données de la distribution de formation. En outre, nous constatons que l’utilisation de l’extraction pour échantillonner d’autres résultats ou réponses est importante pour un CDA efficace. Nous expérimentons également un paramètre QA de domaine ouvert où le modèle ne voit que la question et une fois de plus, nous évaluons sur quatre données hors domaine. Nous constatons que les modèles de référence ne sont pas aussi efficaces pour notre généralisation hors domaine. Cependant, l’amélioration de données avec RGF montre des améliorations plus significatives. Nous nous améliorons même dans les données NQ de domaine. Nous avons émis l’hypothèse que l’amélioration de données contrefactuelle aide le modèle à apprendre de meilleurs encodages de requête pour des requêtes très similaires. Enfin, nous évaluons également la capacité du modèle à améliorer la cohérence dans le voisinage local de la question originale. La cohérence mesure la proportion de questions correctement répondues par le modèle où à la fois la requête originale et celle contrefactuelle reçoivent une réponse correcte. Cela nous aide explicitement à mesurer la robustesse du modèle à de petites perturbations dans le voisinage de la saisie originale. Nous expérimentons avec cinq données qui contiennent des paires de questions sémantiquement proches les unes des autres. Mis à part les trois données AQA, AmbigQA et QUOREF-Contrast définies qui sont déjà disponibles, nous évaluons également sur les contrefactuels RGF qui sont synchronisés avec les questions NQ originales selon qu'elles ont subi un changement de prédicat ou un changement de référence. Ces sous-ensembles ont été annotés en interne pour éliminer le bruit et sont fournis en tant que ressource. Toutes les bases sont incapables d’améliorer de manière significative la cohérence avec le modèle d’ensemble en améliorant la cohérence d’une petite marge. Cependant, l’élargissement contrefactuel du RGF a des gains impressionnants en cohérence à la fois sur les données antérieures et les deux sous-ensembles que nous avons sélectionnés pour les perturbations de référence et de prédicat. Notez que les données RGF améliorées ne sont pas biaisées par le type de perturbation, seuls les ensembles d’évaluation le sont. En effet, une inspection qualitative des types de contrefactuels générés montre que les questions générées contiennent plusieurs perturbations diverses. Par exemple, cette question originale sur la population de Walnut Grove, au Minnesota, est perturbée par différentes dimensions comme la ville, l’État, le pays, et par différents prédicats comme l’emplacement, la pauvreté et le nombre d’écoles. L’audio des perturbations est spécifique au contexte. Par exemple, pour cette autre question sur le tournoi en simple de Wimbledon, la perturbation est liée au type de jeu, au type de tournoi ou au résultat du jeu. Derniers points à retenir : nous abordons la tâche d’amélioration des données contrefactuelle et les perturbations pour les requêtes recherchant des informations et abordons ses défis uniques via un renversement de l’approche de génération, et générons plus en utilisant des quasi-accidents du modèle et un filtre basé sur le type de perturbation ou la minimalité. Nous constatons que cette technique ne nécessite aucune supervision supplémentaire et les exemples sont étiquetés pour l’élargissement. L’élargissement améliore la généralisation de domaine et la cohérence du voisinage. Et nous constatons que les contrefactuels RGF sont sémantiquement divers sans introduire de biais lors de l’élargissement. Merci. 